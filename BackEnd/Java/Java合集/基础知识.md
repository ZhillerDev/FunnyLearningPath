## 第一阶段

### 自动类型转换

多种数据混合运算，系统自动转换为容量大的数据类型后再执行计算

低精度数值赋值给高精度变量，执行自动转换；反过来不行，会报错

`byte、short、char` 之间不会发生相互转换

`boolean` 不参与转换

<br>

### 强转

数据精度从高到低，就需要使用强转

char 类型变量可以保存数字，但是你不能直接把 int 变量赋值给 char 变量

<br>

### String 转换

你可以使用 string 类型的变量转换成任意类型的变量

如下代码

```java
String str = "123";

int num1 = Int.parseInt(str);
float num2 = Float.parseFloat(str);
```

<br>

### 标识符命名规范

包名：所有字母均小写 `com.zhiller.xxx`

类名、接口名：大驼峰 `FoodController`

变量名、方法名：小驼峰 `getName`

常量：全大写，单词之间下划线隔开

<br>

### 原码、反码、补码

二进制最高位是符号位，0 负数，1 正数  
正数的三个码都一样

负数反码：原码符号位不变，其余位取反  
负数补码：反码+1

0 的反码补码均为 0

<br>

### 数组

创建数组

数组初始化器创建数组时，编译器会根据初始化器的元素个数动态计算数组长度，并为数组分配内存空间。  
每个元素的值在编译时就确定了，并且在运行时直接被存储在数组对象中的连续内存位置上。

关键字 new 创建数组时，需要明确指定数组的长度，并在运行时动态分配内存空间。

```java
// 数组初始化器
int[] arr1 = {1,2,3,4,5};

// 关键字new创建数组
int[] arr1 = new int[10];
arr1={1,2,34,5};
```

<br>

## 第二阶段

### 类

可变参数本质上就是一个数组  
可变参数实参可以为 0 个或者任意多个

可变参数可以和普通参数放在一起，但是他必须要在所有参数的最后面（倒数第一个）

一个形参列表仅可存在一个可变参数

```java
public int len(int... nums){
    return nums.length;
}
```

<br>

### 继承

子类继承所有属性和方法；  
非私有属性和方法可以直接在子类访问；  
私有属性必须通过父类公有方法来间接访问；

子类必须调用父类构造器完成初始化

子类默认调用父类无参构造，若父类不含无参构造，则需要借助 super 来指定一个构造函数

`super()`必须放在构造函数第一行

`super()`和 `this()`不可共存

Java 遵循单继承模式，子类只能继承一个父类！

<br>

### Super

super 用于指代父类，如`super.a`就表示调用父类中的公开属性 a

父类中被定义为 final 的属性或方法将无法被重写

对于父类中的私有属性，可以在父类中添加对应的 `getter` 和 `setter` 方法，来让子类间接操纵它

```java
public class SuperDemo {
    public static void main(String[] args) {
        B b = new B(12);
        b.canChange();
        b.cannotChange();
        b.setC(100);
        System.out.println(b.getC());
    }
}

class B extends A {
    public B(int num) {
        super(num);
        System.out.println(super.a);
    }

    @Override
    public void canChange() {
        System.out.println("i changed this method!!!");
    }
}

class A {
    int a, b;

    public int getC() {
        return c;
    }

    public void setC(int c) {
        this.c = c;
    }

    private int c;


    public A() {
        System.out.println("empty a");
    }

    public A(int num) {
        this.a = num;
    }

    public final void cannotChange() {
        System.out.println("this method cannot be changed");
    }

    public void canChange() {
        System.out.println("you can change this method");
    }
}

```

<br>

如果子类中有和父类重名的方法，则调用父类中重名方法时必须使用 super  
若无重名方法，则用 super、this、直接指代都可以！！！

若直接调用方法，会先从当前类开始找，找不到再从父类中找，如果还找不到就一直迭代查询，直到 Object 类为止

若一条继承链上有许多类都出现了同名的方法，则最底层的类使用 super 调用同名方法时，遵循就近原则；  
比如祖父类、父类、子类同时拥有同名方法，则 super 优先安装就近原则调度父类中的同名方法；

<br>

super 与 this 的比较

- this 调用的都是本类中的属性和方法，除非子类没有，才不得不调用父类
- super 直接调用的就是父类属性和方法

<br>

### 重写 Override

重写必背三大规定

1. 子类方法名、参数要和父类完全一致
2. 子类返回值类型必须和父类一样或者为父类返回值类型的子集
3. 子类不可缩小父类访问权限（比如父类 public，子类重写不可以设置为 private）

访问权限大小对比：`public>protected>default>private`

<br>

### 多态

对于方法，可以存在两种多态形式

1. 重载多态：定义同名方法，但参数数量不同，通过传参数量来使用对应的方法
2. 重写多态：B、c 类同时继承 A 类，但俊重写了同名方法 zoo，那么实例化 B、C 类后，调用对应的同名方法就可实现重写多态

<br>

类的多态

对于一个对象，其编译类型和运行类型可以不一致；  
编译类型看等号左边，运行类型看等号右边（如`Animal dog = new Dog()`）；  
编译类型不可变动，但是运行类型可以改变；

```java
public class PolyDemo {
    public static void main(String[] args) {
        Animal dog = getAnimal(new Dog());
        dog.cry();          // dog cry
        dog.walk("tom");    // tom
    }

    private static Animal getAnimal(Animal animal) {
        return animal;
    }
}

class Animal {
    public Animal() {
    }

    public void cry() {
        System.out.println("animal cry");
    }

    public void walk(String name) {
        System.out.println(name);
    }
}

class Dog extends Animal {
    public Dog() {
        super();
    }

    @Override
    public void cry() {
        System.out.println("dog cry");
    }
}
```

<br>

### 多态转型

向上转型：父类引用指向子类对象

`Animal dog = getAnimal(new Dog());`  
此时可以访问父类 Animal 中的所有成员；
若子类还重写了父类中对应方法，那么访问方法时会优先使用子类中重写的方法；  
不能访问在子类 Dog 中新定义的成员！！！（这里不包括子类重写的方法）

<br>

向下转型：子类执行父类的引用

转型后，可以调用子类中的所有方法；且转型内容必须是父类的引用而非父类的对象

```java
Animal animal = new Animal();

Cat cat = (Cat) animal;
```

<br>

如果要检测某个对象是不是每个类的实例，可以借助 instanceOf  
例如：`dog instanceof Animal`

<br>

### 动态绑定

动态绑定的基本原理：

1. 当调用对象方法时，方法会和对象的内存地址与运行类型绑定
2. 当调用对象属性时，无动态绑定，哪里声明就用那个

<br>

分析下方代码：

- 定义父类 BindingA，其中有一个属性值 a=10
- 定义子类 BindingB，重写方法 getNum，而且也同时定义了同名属性 a=20
- 使用向上转型的方法，实例化对象 BindingB
- 此时调用 getNum，因为方法存在动态绑定，故使用子类中重写的方法，返回 a+10
- 由于属性无动态绑定，所以应该使用的是子类中定义的 a=20 而不是父类定义的 a=10，故结果返回 20+10=30

```java
public class DynamicBinding {
    public static void main(String[] args) {
        BindingA b = new BindingB();
        System.out.println(b.getNum());  // 30
    }
}

class BindingA {
    public int a = 10;

    public BindingA() {
    }

    public int getNum() {
        return a;
    }
}

class BindingB extends BindingA {
    public BindingB() {
        super();
    }

    public int a = 20;

    @Override
    public int getNum() {
        return a + 10;
    }
}
```

<br>

### 多态数组

顾名思义，就是在一个数组内体现多态

```java
public class PolyArrDemo {
    public static void main(String[] args) {
        // 定义多态数组
        Fruit[] fruits = new Fruit[3];
        fruits[0] = new Fruit();
        fruits[1] = new Orange();
        fruits[2] = new Pear();

        for (Fruit fruit : fruits) {
            // 根据动态绑定原理，输出不同的值
            fruit.say();
        }
    }
}

class Fruit {
    public void say() {
        System.out.println("this is fruit");
    }
}

class Pear extends Fruit {
    @Override
    public void say() {
        System.out.println("pear");
    }
}

class Orange extends Fruit {
    @Override
    public void say() {
        System.out.println("orange");
    }
}
```

<br>

如果你想要特定的调用每个子类中的新定义的方法

可以先使用 `instanceOf` 判断当前对象是不是子类的一个实例，如果是，再执行调用

所以上文的 for 循环体内可以加个判断，写成下面的样子（我为 Orange 添加了新方法 eatOrange，这里不给出，大家自己实现即可）

```java
for (Fruit fruit : fruits) {
    if (fruit instanceof Orange) ((Orange) fruit).eatOrange();
    fruit.say();
}
```

<br>

### ==运算符

`==`有两种作用

- 进行数值比较，判断两个数是否一致
- 进行地址比较

<br>

下面的赋值方法为引用赋值，故之间地址比较均为 true

```java
A a = new A();
A b = a;
System.out.println(a==b); // true
```

<br>

### hashCode

> hashCode 用于返回一个对象的哈希值，用于提升哈希表效率

两个引用指向同一对象，哈希值必定一致；  
哈希值一致不一定表示引用指向同一对象；

哈希值不完全等于地址值

<br>

### finalize 方法

对象被垃圾回收时，自动调用的方法；  
可以重写该方法，让对象再被释放资源前做一些什么；

采用引用计数法，当 JVM 发现某个对象的引用次数为 0 时，就会执行垃圾回收程序来释放该对象资源

GC 机制由系统决定，当然也可以使用 `System.gc()` 主动触发回收

<br>

## 第三阶段

### 类变量

类变量实际上就是普通变量加上一个 static  
也称为静态变量

该变量会被该类的所有实例所共享；

```java
class A{
    public static int count = 0;
}
```

直接使用 `类名.类变量名` 来执行访问

没有加上 static 的就是所谓的实例变量

类被加载时，类变量就初始化完毕了，就是说你无需实例化对象就可以直接从类调用该类变量

类变量的生命周期是：类初始化开始到其销毁为止

<br>

### 类方法

类方法也就是静态方法

普通方法加上一个 static 即可，具体调用方法和作用可以直接参考类变量

类方法可以通过类名调用，也可以通过对象名调用；  
类方法随类的初始化而加载，结构信息存储于方法区；  
类方法无 this 参数，而普通方法有 this 参数；

<br>

> 静态方法只能访问静态的成员（即静态属性和静态方法）；普通方法则无限制

<br>

### main 方法

由于 main 方法自己就是一个静态方法，故也只能调用同类内的静态成员

对于普通成员，则需要实例化自身再执行调用

```java
package chapter2;

public class MainDemo {
    public static void main(String[] args) {
        // 静态方法可以直接调用
        MainDemo.func1();

        // 非静态方法必须实例化自身才可以调用
        MainDemo mainDemo = new MainDemo();
        mainDemo.func2();
    }
    public static void func1(){
        System.out.println("static function");
    }
    public void func2(){
        System.out.println("normal function");
    }
}
```

<br>

众所周知，main 方法接收一个 args 字符串数组，用于命令行添加可变长参数

所以当我们使用命令行执行 java 程序是，可以传入任意长度的参数：  
`java [类名称] asd asd asd`

<br>

### 代码块

代码块有两种：static 代码块和普通代码块

static 代码块可看做对类的初始化，它随着类的加载而执行，且仅执行一次；  
普通代码块是当每个对象被创建就执行一次；

类被加载的时刻：

1. 创建对象实例
2. 创建子类对象实例，父类会被加载
3. 使用类内静态成员

> 普通代码块只有在对象实例化才会被调用，故我们直接使用类内静态成员而不实例化对象，是不会触发普通代码块的！

<br>

创建一个类时，对应的调用顺序：

1. 静态代码块（如果有多个，则按顺序调用）
2. 普通代码块（如果有多个则按顺序调用）
3. 构造函数

<br>

创建一个子类是，对应的调用顺序

1. 父类静态代码块和静态属性
2. 子类静态代码块和静态属性
3. 父类普通代码块与普通属性初始化
4. 父类构造函数
5. 子类普通代码块与普通属性初始化
6. 子类构造函数

<br>

### 单例模式

#### 饥饿式

```java
class Single1 {
    private Single1() {
    }

    private static final Single1 instance = new Single1();

    public static Single1 getInstance() {
        return instance;
    }
}
```

<br>

#### 懒汉式

```java
class Single2 {
    private Single2() {
    }

    private static Single2 instance;

    public static Single2 getInstance() {
        if (instance == null) {
            instance = new Single2();
        }
        return instance;
    }
}
```

<br>

### final

final 经常被称为终结修饰符，被他修饰后一般具有如下功能

1. 阻止类被继承
2. 阻止父类的方法被覆写
3. 阻止属性被修改
4. 阻止局部变量被修改

<br>

被 final 修饰的属性只能在两个位置初始化：定义时；静态代码块里面；  
不要试图在构造函数里面为 final 变量赋值！！！

你没有必要在为一个 final 类下的方法设置 final 修饰

final 和 static 搭配工作效率更高哦！

<br>

### 抽象类

抽象类必背规则

1. 抽象类不可实例化
2. 抽象类可以没有抽象方法
3. 类内只要存在一个抽象方法，他就必须声明为抽象类
4. abstract 仅能修饰方法和类
5. 抽象类内可以有任何普通类所拥有的成员
6. 一个类继承了抽象类，就必须实现其中所有的抽象方法，除非这个类也是抽象类
7. 抽象方法不能有函数体
8. 抽象方法不可用 private，final，static 等阻止重写的修饰符来修饰

<br>

简易的根据上述知识构筑的抽象类和抽象方法实验代码

```java
package chapter2;

public class AbstractDemo {
    public static void main(String[] args) {
        AbstractEntity entity = new AbstractEntity();
        entity.getName();
        entity.sayHi();
    }
}

abstract class Abstract1 {
    public abstract void getName();

    public void sayHi() {
        System.out.println("hw");
    }
}

class AbstractEntity extends Abstract1{
    @Override
    public void getName() {
        System.out.println("no name");
    }
}
```

<br>

### 接口

接口内的静态方法、默认方法可以自带函数体，其余的函数都不可以有函数体

```java
interface USBInterface {
    public void getType();

    // 默认方法
    default public void defTest(){
        System.out.println("default test");
    }

    // 静态方法
    public static void staticTest() {
        System.out.println("static test");
    }
}
```

<br>

接口使用细节

1. 接口不可以实例化
2. 接口中的抽象方法无需加 abstract 修饰符
3. 接口中所有方法均为 public
4. 普通类实现接口，必须重写方法；抽象类实现接口，可以一个方法都不重写
5. 一个类可实现多个接口
6. 接口属性只能是 final 的
7. 访问接口属性，使用格式：`接口名.属性名`
8. 接口可以额外继承多个其他接口 `interface B extends A,C{}`

<br>

接口也可以实现多态，下面展示了数组多态

```java
package chapter2;

public class InterfaceDemo {
    public static void main(String[] args) {
        Device[] devices = new Device[2];
        devices[0] = new Phone();
        devices[1] = new Computer();

        for (Device device : devices) {
            if (device instanceof Phone) ((Phone) device).call();
            else device.work();
        }
    }
}

interface Device {
    void work();
}

class Phone implements Device {
    @Override
    public void work() {
        System.out.println("phone work");
    }

    public void call() {
        System.out.println("打电话了");
    }
}

class Computer implements Device {
    @Override
    public void work() {
        System.out.println("computer work");
    }
}
```

<br>

接口多态传递现象

比如下方，A2 继承了接口 A1，那么我们的类实现了 A2 接口的同时也顺便实现了 A1 接口，呈现传递关系

```java
package chapter2;

public class InterfacePolyLinkDemo {
    public static void main(String[] args) {
        A1 aa1 = new A();
        A2 aa2 = new A();
    }
}

interface A1 {
}

interface A2 extends A1 {
}

class A implements A2 {
}
```

<br>

### 内部类

#### 局部内部类

> 定义于方法中，而且有类名

可访问外部类所有成员，包括私有  
不可添加访问修饰符，但可以 final 修饰  
作用域仅仅是方法内部

如果内部类有和外部类同名的属性或者方法，可以使用以下格式：`外部类名.this.外部类属性或者方法名`

```java
package chapter3;

public class LocalInnerClass {
    public static void main(String[] args) {
        new LocalClass().getNum();
    }
}

class LocalClass {
    private int outNum = 1;

    public void getNum() {

        // 定义局部内部类 InnerClass
        class InnerClass {
            private int outNum = 2;

            public void say() {
                // 输出局部内部类的 outNum，即 2
                System.out.println(outNum);
                // 输出外部类的 outNum，即 1
                System.out.println(LocalClass.this.outNum);
            }
        }
        // 创建 InnerClass 的实例并调用 say() 方法
        new InnerClass().say();
    }
}
```

<br>

#### 匿名内部类

> 定义于方法内，但是是匿名的

我们需要提供一个接口，来让匿名内部类有一个模板来参照

```java
package chapter3;

public class AnonymousInnerClass {
    public static void main(String[] args) {
        new AnonymousClass().getWhatSay();
    }
}

interface A {
    void say();
}

class AnonymousClass {
    public void getWhatSay() {
        // 匿名内部类
        new A() {
            @Override
            public void say() {
                System.out.println("fuck");
            }
        }.say();
    }
}
```

<br>

匿名内部类的一个重要方法是把他当做一个实参来传递，从而简化代码操作

```java
package chapter3;

public class AnonymousInnerClass {
    public static void main(String[] args) {
        // 调用方法，直接传入一个匿名类实现
        sayHello(new A() {
            @Override
            public void say() {
                System.out.println("hello world");
            }
        });
    }

    // 接收一个接口作为形参
    public static void sayHello(A a){
        // 调用接口方法
        a.say();
    }
}

interface A {
    void say();
}
```

<br>

#### 成员内部类

> 直接作为外部类的一个成员出现，不被 static 修饰

他可以添加任何访问修饰符

内部类可以访问外部类所有成员，反过来也是一样的

```java
package chapter3;

public class MemberInnerClass {
    public static void main(String[] args) {
        new MemberClass().sayHello();
    }
}

class MemberClass {
    private int num = 100;

    public void sayHello() {
        System.out.println("fuck");
        InnerClass innerClass = new InnerClass();
        System.out.println(innerClass.getNum() + innerClass.res);
    }

    class InnerClass {
        private int res = 1000;

        public int getNum() {
            return MemberClass.this.num;
        }
    }
}
```

<br>

#### 静态内部类

> 直接作为外部类的一个成员出现， static 修饰

跟所有被 static 修饰的成员一样，该内部类只能访问外部类的静态成员

<br>

### 枚举类

枚举类的定义比较复杂

依据下方代码做出解释

1. 枚举常量必须位于枚举类最顶端，他表示我们需要使用的常量
2. 定义私有属性，这些属性将成为枚举常量中的参数
3. 定义构造函数，构造函数的格式对应枚举常量的格式，一一赋值给私有属性
4. 定义私有属性的 getter，这样外界才可以获取枚举常量中的参数值

```java
package chapter3;

public class EnumClass {
    public static void main(String[] args) {
        Persons[] persons = Persons.values();
        for (Persons person : persons) {
            StringBuilder sb = new StringBuilder();
            sb.append(person.getAge());
            sb.append(person.getName());
            sb.append(person.name());
            System.out.println(sb.toString());
        }
    }
}

enum Persons {
    JACK("jack", 12),  // 枚举常量 JACK，名称为 "jack"，年龄为 12
    TOM("tom", 13),   // 枚举常量 TOM，名称为 "tom"，年龄为 13
    WHITE("white", 41),  // 枚举常量 WHITE，名称为 "white"，年龄为 41
    ALIEN("undefined");  // 枚举常量 ALIEN，名称为 "undefined"，使用默认年龄 999

    private final String name;  // 枚举常量的名称
    private final int age;  // 枚举常量的年龄

    // 枚举常量的构造方法，接受名称和年龄
    Persons(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 枚举常量的构造方法，只接受名称，年龄使用默认值 999
    Persons(String name) {
        this.name = name;
        this.age = 999;
    }

    // 获取枚举常量的名称
    public String getName() {
        return name;
    }

    // 获取枚举常量的年龄
    public int getAge() {
        return age;
    }
}
```

<br>

或者，直接使用最简单的办法，所有枚举常量本身就是一个字符串常量  
他们不需要任何参数，只需要再被用到时取出 `name()` 即可

```java
public class EnumClass {
    public static void main(String[] args) {
        GENDER boy = GENDER.BOY;
        GENDER girl = GENDER.GIRL;
        System.out.println(boy.name());
    }
}

enum GENDER {
    BOY, GIRL;
}
```

<br>

因为枚举类 enum 默认隐式继承了 Enum，所以你没法再用 extends 了，但是还是可以实现接口的！

枚举类挂载多个接口然后实现他们，就可以直接被外界调用

```java
package chapter3;

public class EnumInterfaceClass {
    public static void main(String[] args) {
        // 直接通过枚举常量调用对应接口方法
        BB.ASD.say();
    }
}

// 接口
interface B {
    void say();
}

enum BB implements B {

    ASD("asd"), QWE("qwe");

    private final String msg;

    BB(String msg) {
        this.msg = msg;
    }

    // 实现对应的方法
    @Override
    public void say() {
        System.out.println(msg);
    }
}
```

### 注解

三个常见的注解：

- `@Override` 重写注解
- `@Deprecated` 表示方法已被废弃
- `@SuppressWarnings` 抑制编译器警告

<br>

#### @Override

只能修饰方法

只能指定为重写父类的方法，如果父类没有该方法，就会报错

`@Target` 是修饰注解的注解，也被称为元注解

<br>

#### @Deprecated

可以标注所有类型成员

表示该类型已经过时，用于新旧版本切换过度

<br>

#### @SuppressWarnings

抑制编译器警告

抑制的范围根据你放置该注解的位置有关

你可以通过指定抑制哪一个方面的注解，对应抑制名称可以上网查

```java
@SuppressWarnings({"unchecked"})
public void asd(){}
```

<br>

#### 四种元注解

`@Retention`：用于指定被注解的注解的保留策略。注解的保留策略决定了注解在编译时、类加载时或运行时可见。  
他接受一个参数，可选取值为：

- RetentionPolicy.SOURCE：注解仅保留在源代码中，在编译后不会包含在编译好的文件中。
- RetentionPolicy.CLASS：注解保留在编译后的字节码文件中，但不会被加载到虚拟机中，在运行时不可见。
- RetentionPolicy.RUNTIME：注解保留在编译后的字节码文件中，并被加载到虚拟机中，在运行时可通过反射机制获取。

`@Target`：用于指定被注解的注解可以应用于哪些元素上。注解可以应用于类、方法、字段等不同的元素上，@Target 用于限制注解的使用范围。  
@Target 接受一个参数 ElementType[]，表示注解可以应用于的元素类型。

`@Documented`：用于指定被注解的注解是否包含在 Java 文档中。如果一个注解被标注了该注解 d，则在生成 Java 文档时，该注解会包含在文档中。

`@Inherited`：用于指定被注解的注解是否可以被继承。当一个类被继承时，是否继承父类上的注解。

<br>

### 异常

异常可以划分为两类：

1. Error：JVM 无法解决的严重问题，如系统内部错误或者资源耗尽等情况
2. Exception：一般性错误，如空指针异常；他又可以分为两大类：
   - 运行时异常：不要求强制处理的异常，一般都是编程时的逻辑错误
   - 编译时异常：编译器要求必须处理的异常

<br>

#### 运行时异常

常见的运行时异常：

1. NullPointerException（空指针异常）：当代码尝试使用一个空对象的方法或访问空对象的属性时抛出。
2. ArrayIndexOutOfBoundsException（数组越界异常）：当尝试访问数组中不存在的索引时抛出。
3. ClassCastException（类转换异常）：当尝试将一个对象强制转换为不兼容的类型时抛出。
4. NumberFormatException（数字格式异常）：当字符串无法转换为数字类型时抛出，例如使用 Integer.parseInt 时传入的字符串不是合法的数字格式。
5. ArithmeticException（算术异常）：当进行算术运算时出现错误，例如除以零或模运算时除数为零。
6. IllegalArgumentException（非法参数异常）：当传递给方法的参数不合法或无效时抛出，例如传递了空对象或不允许的参数值。
7. IllegalStateException（非法状态异常）：当对象处于不允许的状态时抛出，例如在不正确的时间调用方法或操作。
8. IndexOutOfBoundsException（索引越界异常）：当访问集合（如列表或字符串）中不存在的索引时抛出。
9. ConcurrentModificationException（并发修改异常）：当在迭代集合的同时，使用不允许的方式（如修改集合）进行修改时抛出。
10. UnsupportedOperationException（不支持的操作异常）：当调用不支持的方法或操作时抛出，通常是因为对象不支持特定的操作。

<br>

#### 捕获异常

最简单的 try catch 代码块来捕获异常

子类异常写在前面，父类异常写在后面

finally 表示无论如何都会执行的代码

```java
package chapter4;

public class Exp1 {
    public static void main(String[] args) {
        try {
            String str = "123";
            int num = Integer.parseInt(str);
            System.out.println(num);
        } catch (NumberFormatException e) {
            e.printStackTrace();
        } finally {
            System.out.println("我一直会被执行");
        }
    }
}
```

<br>

#### 抛出异常

我们可以直接摆烂，不去主动处理异常，而是由子类去处理

此时可以使用 throw 抛出异常，抛出的异常可以是当前异常的父类；  
如果你为了省事，可以直接 `throw Exception`

```java
package chapter4;

public class Exp2 {
    public static void main(String[] args) {
        try {
            int num = new Exp2().getNum("asd");
            System.out.println(num);
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }

    public int getNum(String str) throws NumberFormatException {
        return Integer.parseInt(str);
    }
}
```

<br>

编译时异常一定要处理或者抛出；运行时异常一般直接抛出；

如果你已经处理异常，就没必要抛出异常了

<br>

#### 自定义异常

```java
package chapter4;

import java.util.Scanner;

public class Exp3 {
    public static void main(String[] args) {
        int age = 100;
        if (age < 100) throw new CustomException("你的数字不对");
    }
}

class CustomException extends RuntimeException {
    public CustomException(String message) {
        super(message);
    }
}
```

<br>

## 第四阶段

### 包装类

装箱拆箱以及手动自动

```java
package chapter4;

public class Pack {
    public static void main(String[] args) {
        // 自动装箱
        int a = 100;
        Integer aa = a;
        // 自动拆箱
        int b = aa;

        // 手动装箱
        Integer a2 = Integer.valueOf(a);
        // 手动拆箱
        int b2 = a2.intValue();
    }
}
```

<br>

### String

string 类的几个特性

1. 实现了接口 Serializable（支持串行化），和 Comparable（表示可以被比较）
2. 它是 final 类，不可被继承
3. 他有一个属性 value，用于存放字符串内容
4. value 被 final 修饰，不可以直接修改

<br>

直接赋值`String s1 = "asd"`：从常量池查看是否有 asd 的空间，如果有就直接指向它；如果没有就重新常见并指向它；  
s1 最终指向常量池的地址

构造器赋值`String s2 = new String("asd")`：堆中先创建空间，维护 value 属性，指向 asd 空间；如果常量池没有 asd 那就重新创建并通过 value 指向；  
s2 最终指向堆中地址

<br>

`str = s1 + s2` 变量相加，操作在常量池中；

`str = "asd" + "asd"` 常量相加，操作在堆中；

<br>

### StringBuffer

StringBuffer 和 StringBuilder 均为可变字符序列，不像 String 一样直接就 final 终结掉了

StringBuffer 是线程安全的，但是 StringBuilder 不是

当字符串缓冲区被单个线程使用是，推荐直接上 StringBuilder，因为其优化较好，速度快

<br>

由于 String 的 value 属性被 final，故我们每次对 string 类型变量进行相加操作时，实际上是先把旧的副本丢掉，并生成新的结果重新赋予变量；这样会导致大量副本留在内存形成碎片，影响性能

<br>

### Arrays

使用 Arrays 可以对数组进行基本的操作

```java
package chapter4;

import java.util.Arrays;

public class ArraysDemo {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        System.out.println(Arrays.toString(arr));
        Arrays.sort(arr);
        System.out.println(Arrays.binarySearch(arr, 3));
    }
}
```

<br>

传入自定义 comparable 接口，来实现排序方式多样化  
实现降序排序

```java
package chapter4;

import java.util.Arrays;
import java.util.Comparator;

public class ArraysDemo {
    public static void main(String[] args) {
        Integer[] numbers = {5, 2, 8, 1, 9};

        // 使用自定义的Comparator进行降序排序
        Arrays.sort(numbers, new Comparator<Integer>() {
            @Override
            public int compare(Integer a, Integer b) {
                // 降序排序，将比较结果反转
                return b.compareTo(a);
            }
        });

        // 输出排序结果
        for (Integer number : numbers) {
            System.out.println(number);
        }
    }
}
```

<br>

### System

`System.arraycopy` 执行数组复制  
五个参数分别为：原数组，原数组起始索引，目标数组，目标数组起始索引，欲复制多少个元素

```java
package chapter4;

import java.util.Arrays;

public class SystemDemo {
    public static void main(String[] args) {
        int[] arr1 = {1, 31, 4, 12, 3, 12};
        int[] arr2 = new int[3];
        System.arraycopy(arr1, 0, arr2, 0, 3);
        System.out.println(Arrays.toString(arr2));
    }
}
```

<br>

BigInteger 大数整数类型  
需要使用大数类型提供的方法来进行加减乘除运算

同理，还存在一个高精度小数大数运算

```java
package chapter4;

import java.math.BigInteger;

public class BigNum {
    public static void main(String[] args) {
        BigInteger bigInteger1 = new BigInteger("12839371293");
        BigInteger bigInteger2 = bigInteger1.add(bigInteger1);
        System.out.println(bigInteger2);
    }
}
```

<br>

### Date
