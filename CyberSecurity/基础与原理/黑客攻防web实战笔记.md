### 第二章 核心防护机制

#### 处理用户输入

所有的用户输入都不可信；

**边界确认（boundary validation）**  
一种更加有效的模型。此时，服务器端应用程序的每一个单独的组件或功能单元将其输入当做来自潜在恶意来源的输入对待。

某些站点会设置过滤器过滤掉 script 标签，但是由于过滤器无法递归执行，则使用此代码 `<scr<script>ipt>` ，在内部的 script 标签被过滤掉后，外部的又可以重新组成一个 script 标签！

浏览器规范化操作依然可能会导致攻击者通过使用编码避开确认机制

<br>

#### 攻击者与管理人员

保护不严密的审计日志可能为攻击者提供大量信息，向其披露许多敏感信息，如会话令牌和请求参数，这些信息可能会使攻击者能够立即攻破整个应用程序

进行实时警报的最有效方法是将其与应用程序的输入确认机制和其他控制方法紧密结合起来

<br>

### 第三章 web 应用程序技术

表述性状态转移（REST）是分布式系统的一种体系架构，在这类体系架构中，请求和响应包含系统资源当前状态的表述

**URL 编码字符**  
都以%为前缀，其后是这个字符的两位十六进制 ASCII 代码  
%3d 代表=；
%25 代表%；  
%20 代表空格；  
%0a 代表新行；  
%00 代表空字节。

<br>

16 位 Unicode 编码的字符以%u 为前缀，其后是这个字符的十六进制 Unicode 码点  
UTF-8 编码的多字节字符以%为前缀，其后用十六进制表示每个字节

<br>

**Base64 编码**  
使用该编码则可以仅用一个可打印的 ASCII 字符就可安全转换任何二进制数据  
Base64 编码将输入数据转换成 3 个字节块。每个块被划分为 4 段，每段 6 个数据位。这 6 个数据位有 64 种不同的排列，因此每个段可使用一组 64 个字符表示

<br>

### 第五章 避开客户端的组件

#### 通过客户端传输数据

HTML 中存在的隐藏表单虽然不会对用户显示出来，但仍然会被提交；  
我们可以使用 burpsuite 软件对包进行拦截，修改隐藏表单域的数值来伪造原值并发送给服务端，执行欺骗

不要信任 HTTP 请求头，脚本小子们可以轻易地使用 burpsuite 篡改它并伪造数据

**模糊字符串**  
客户端对数值进行加密而使其变得“模糊化”，尝试使用某些异常字符串作为模糊字符串发送给服务端来寻找可能存在的漏洞

<br>

#### HTML 表单

如果遇到长度限制表单，可以拦截包含表单的响应，并删除 maxlength 属性，即可避开检测

某些服务端并没有采取客户端确认机制，即你拦截发包后篡改数值发送给服务端后他依然接收并成功处理

**客户端限制解除简要步骤**

1. 在客户端先填入一个正常值并 submit
2. 拦截该包，修改正常值为恶意值，再发给服务器

<br>

**禁用元素**  
可以使用 burpsuite 修改 HTML 中禁用的元素，或者拦截发包并查看其中是否包含了禁用元素的值，以便判断入侵角度

<br>

#### 浏览器扩展

版本过老，停止介绍！

<br>

### 第六章 攻击验证机制

输入密码错误过多会锁定账户，实际上这对于入侵者没有任何作用，入侵者仍然可以无限发包猜测密码并等到账户解锁的那一刻填入正确口令

我们注册账户时通常会填写一些问题，譬如“你最喜欢吃的食物？”这些玩意，攻击者可以从这里入手，或者寻找漏洞
