## JVM 第一部分：内存与垃圾回收

<br>

### JVM 与 Java 体系结构

<br>

#### 虚拟机与 Java 虚拟机

系统虚拟机：完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台  
Java 虚拟机：它专门为执行单个计算机程序而设计

Java 技术的核心就是 Java 虚拟机（JVM，Java Virtual Machine）

Java 编译器输入的指令流基本上是一种基于 `栈的指令集架构`

**栈式架构**的特点：使用零地址指令方式分配，指令集更小，不需要硬件支持，可移植性更好  
**寄存器架构**的特点：完全依赖硬件，可移植性差，往往都以一地址指令、二地址指令和三地址指令为主

<br>

#### JVM 生命周期

虚拟机退出的情况

- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统用现错误而导致 Java 虚拟机进程终止
- 某线程调用 Runtime 类或 system 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。
- 除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况。

<br>

### 类加载子系统

<br>

#### 内存结构

![](../img/jvm/j1.png)

<br>

#### 类加载器

**类加载器子系统作用**

- 类加载器子系统负责从文件系统或者网络中加载 Class 文件
- ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定
- 加载的类信息存放于一块称为方法区的内存空间

**加载阶段**

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

**链接阶段**

1. 验证：确保 Class 文件的字节流中包含信息符合当前虚拟机要求
2. 准备：为类变量分配内存并且设置该类变量的默认初始值，不会为实例变量分配初始化
3. 解析：将常量池内的符号引用转换为直接引用的过程

**初始化阶段**

- 初始化阶段就是执行类构造器方法`<clinit>()`的过程
- 构造器方法中指令按语句在源文件中出现的顺序执行

<br>

#### 类加载器分类

JVM 支持两种类型的类加载器 。分别为`引导类加载器（Bootstrap ClassLoader）`和`自定义类加载器（User-Defined ClassLoader）`。

<br>

![](../img/jvm/j2.png)

虚拟机自带的加载器

1. 启动类加载器（引导类加载器，Bootstrap ClassLoader）：用来加载 Java 的核心库，加载扩展类和应用程序类加载器，并指定为他们的父类加载器
2. 扩展类加载器（Extension ClassLoader）：派生于 ClassLoader 类
3. 应用程序类加载器（系统类加载器，App ClassLoader）：负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库，Java 应用的类都是由它来完成加载

> ClassLoader 类是一个抽象类，其后所有的类加载器都继承自 ClassLoader

<br>

#### 双亲委派

Java 虚拟机对 class 文件采用的是按需加载的方式  
而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式

**工作原理**

- 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；
- 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；
- 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。

![](../img/jvm/j3.png)

<br>

**沙箱安全机制**

自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件`（rt.jar 包中 java\lang\String.class）`，报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。

<br>

#### 其余

**如何判断两个 class 对象是否相同**

- 类的完整类名必须一致，包括包名。
- 加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。

Java 程序对类的使用方式分为：主动使用和被动使用

<br>

### 运行时数据区及程序计数器

<br>

#### 运行时数据区

线程私有与共享分异

- 每个线程：独立包括程序计数器、栈、本地栈。
- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

每个 JVM 只有一个 Runtime 实例。即为运行时环境

<br>

Hotspot JVM 里，每个线程都与操作系统的本地线程直接映射

当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。

虚拟机线程：这种线程的操作是需要 JVM 达到安全点才会出现。

<br>

#### 程序计数器(PC 寄存器)

`PC 寄存器`用来存储指向下一条指令的地址，也即将要执行的指令代码

每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致（为了能够准确地记录各个线程正在执行的当前字节码指令地址）

每个线程在创建后，都会产生自己的程序计数器和栈帧  
任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法

PC 寄存器唯一一个在 Java 虚拟机规范中没有规定任何 OutofMemoryError 情况的区域

<br>

### 虚拟机栈

<br>
