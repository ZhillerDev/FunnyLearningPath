### 设计模式简介

#### 五大设计原则

1. `单一职责`：一个程序只需要做好一件事。如果功能过于复杂就拆分开，保证每个部分的独立
2. `开放封闭原则`:对扩展开放，对修改封闭。增加需求时，扩展新代码，而不是修改源代码。这是软件设计的终极目标。
3. `里氏置换原则`：子类能覆盖父类，父类能出现的地方子类也能出现。
4. `接口独立原则`：保持接口的单一独立，避免出现“胖接口”。这点目前在 TS 中运用到。
5. `依赖倒置原则`：面向接口编程，依赖于抽象而不依赖于具体。使用方只专注接口而不用关注具体类的实现。俗称“鸭子类型”

<br>

#### 三个主要设计模式大类

1. `创建型`：工厂模式，抽象工厂模式，建造者模式，单例模式，原型模式
2. `结构型`：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式
3. `行为型`：策略模式，模板方法模式，发布订阅模式，迭代器模式，职责链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式。

<br>

### 23 个设计模式一句话总结

#### 工厂模式

根据用户需求构造一个新的指定的类

<br>

#### 抽象工厂模式

通过类的抽象使得业务适用于一个产品类簇的创建，而不负责某一个类产品的实例

<br>

#### 建造者模式

为用户返回一个由多个组件构成的复杂系统；
将一个复杂对象的构建与他的表现分离，使得同样的构建过程可以创建不同的表示；

<br>

#### 单例模式

创建一个唯一的对象

<br>

#### 适配器模式

解决对象之间的接口不兼容的问题；
不更改源代码的情况下，让两个原本不兼容的对象在调用时正常工作；

<br>

#### 装饰器模式

不更改源代码自身的情况下，对其进行职责添加

<br>

#### 代理模式

使用者通过一个顶层对象的代理来间接控制顶层对象

<br>

#### 外观模式

封装交互，隐藏系统的复杂性，提供一个可以访问的接口；
由一个将子系统一组的接口集成在一起的高层接口，以提供一个一致的外观，减少外界与多个子系统之间的直接交互；

<br>

#### 发布订阅模式/观察者模式

定义对象之间的 1 对 N 的依赖关系，当其中一个对象发生变化时，所有依赖于它的对象都会得到通知

<br>

#### 迭代器模式

提供一种方法顺序访问一个聚合对象中的每个元素，并且不需要暴露该对象的内部

<br>

#### 状态模式

允许一个对象在其内部状态改变的时候改变其行为

<br>

#### 策略模式

定义许多算法并将他们封装，目的是吧算法和算法实现隔离；

<br>

#### 命令模式

向某个对象（该对象存在与否未知）发送指令

<br>

#### 组合模式

由一些小的子对象构建出的更大的对象，而这些小的子对象本身可能也是由多个孙对象组合而成的

<br>

#### 模块方法模式

类似于继承方式，然而 js 里面压根没有继承这玩意

<br>

#### 享元模式

运用共享技术来有效支持大量的细粒度对象；
（简单点，可以理解为合并同类项）

<br>

#### 职责链模式

使用多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象链成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止

<br>

#### 中介模式

解除对象与对象之间的紧密耦合关系;
（即对象之间都会通过中介来通信）

<br>

#### 原型模式

克隆自身，生成一个新的对象
（可以快速构造一大批对象）

<br>

#### 备忘录模式

不破坏封装的前提下，捕获一个对象内部状态，并在该对象之外保存这个状态，以保证以后可以将对象恢复到原先的状态

<br>

#### 桥接模式

将抽象部分与它的实现部分分离，使它们各自独立的变化，通过使用组合关系代替继承关系，降低抽象和实现两个可变维度的耦合度

<br>

#### 访问者模式

将数据的操作和数据的结构进行分离，对数据中各元素的操作封装独立的类，使其在不改变数据结构情况下扩展新的数据

<br>

#### 解释器模式

它实现了一个表达式接口该接口，该接口解释一个特定的上下文

<br>

### 面试题

#### 简单工厂模式和工厂方法模式的区别

简单工厂模式：包含判断什么对象的逻辑，采用了静态方法，不利于继承，并且需要修改工厂类；  
工厂方法模式：需要调用者判断要实例化什么具体类型的工厂进而创建出想要的对象，遵守了开闭原则；

<br>

####
