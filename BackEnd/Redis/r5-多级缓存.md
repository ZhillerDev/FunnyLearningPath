## 多级缓存含义

多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻 Tomcat 压力，提升服务性能：

- 浏览器访问静态资源时，优先读取浏览器本地缓存
- 访问非静态资源（ajax 查询数据）时，访问服务端
- 请求到达 Nginx 后，优先读取 Nginx 本地缓存
- 如果 Nginx 本地缓存未命中，则去直接查询 Redis（不经过 Tomcat）
- 如果 Redis 查询未命中，则查询 Tomcat
- 请求进入 Tomcat 后，优先查询 JVM 进程缓存
- 如果 JVM 进程缓存未命中，则查询数据库

<br>

在多级缓存架构中，Nginx 内部需要编写本地缓存查询、Redis 查询、Tomcat 查询的业务逻辑，因此这样的 nginx 服务不再是一个**反向代理服务器**，而是一个编写**业务的 Web 服务器了**。

既然 nginx 用作 web 服务器了，那么必然需要另外一个 nginx 当做反向代理服务器

<br>

## JVM 进程缓存

<br>

### Caffeine

**Caffeine**是一个基于 Java8 开发的，提供了近乎最佳命中率的高性能的本地缓存库。

目前缓存有两种形式：

- 分布式缓存，如 redis
- 进程本地缓存，如 HashMap、GuavaCache

<br>

如何使用 caffeine 的缓存功能呢？请看如下示例代码

```java
@Test
void testBasicOps() {
    // 构建cache对象
    Cache<String, String> cache = Caffeine.newBuilder().build();

    // 存数据
    cache.put("gf", "迪丽热巴");

    // 取数据
    String gf = cache.getIfPresent("gf");
    System.out.println("gf = " + gf);

    // 取数据，包含两个参数：
    // 参数一：缓存的key
    // 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑
    // 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式
    String defaultGF = cache.get("defaultGF", key -> {
        // 根据key去数据库查询数据
        return "柳岩";
    });
    System.out.println("defaultGF = " + defaultGF);
}
```

<br>

Caffeine 提供了三种缓存清除策略：

- **基于容量**：设置缓存的数量上限

  ```java
  // 创建缓存对象
  Cache<String, String> cache = Caffeine.newBuilder()
      .maximumSize(1) // 设置缓存大小上限为 1
      .build();
  ```

- **基于时间**：设置缓存的有效时间

  ```java
  // 创建缓存对象
  Cache<String, String> cache = Caffeine.newBuilder()
      // 设置缓存有效期为 10 秒，从最后一次写入开始计时
      .expireAfterWrite(Duration.ofSeconds(10))
      .build();

  ```

- **基于引用**：设置缓存为软引用或弱引用，利用 GC 来回收缓存数据。性能较差，不建议使用。

<br>

### 进程缓存的实现

首先，我们需要定义两个 Caffeine 的缓存对象，分别保存商品、库存的缓存数据。

在 item-service 的`com.heima.item.config`包下定义`CaffeineConfig`类：

```java
package com.heima.item.config;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.heima.item.pojo.Item;
import com.heima.item.pojo.ItemStock;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CaffeineConfig {

    @Bean
    public Cache<Long, Item> itemCache(){
        return Caffeine.newBuilder()
                .initialCapacity(100)
                .maximumSize(10_000)
                .build();
    }

    @Bean
    public Cache<Long, ItemStock> stockCache(){
        return Caffeine.newBuilder()
                .initialCapacity(100)
                .maximumSize(10_000)
                .build();
    }
}
```

然后，修改 item-service 中的`com.heima.item.web`包下的 ItemController 类，添加缓存逻辑：

```java
@RestController
@RequestMapping("item")
public class ItemController {

    @Autowired
    private IItemService itemService;
    @Autowired
    private IItemStockService stockService;

    @Autowired
    private Cache<Long, Item> itemCache;
    @Autowired
    private Cache<Long, ItemStock> stockCache;

    // ...其它略

    @GetMapping("/{id}")
    public Item findById(@PathVariable("id") Long id) {
        return itemCache.get(id, key -> itemService.query()
                .ne("status", 3).eq("id", key)
                .one()
        );
    }

    @GetMapping("/stock/{id}")
    public ItemStock findStockById(@PathVariable("id") Long id) {
        return stockCache.get(id, key -> stockService.getById(key));
    }
}
```

<br>

## Lua 语法

<br>

### Helloworld

ubuntu 下默认不自带 lua 环境，自己下载一个：`sudo apt install lua5.4`

新建一个 lua 文件 `touch l.lua`

vim 进入该文件并写下第一行代码 `print("fuck lua")`

退出并保存文件，然后执行 lua 脚本 `lua l.lua`

<br>

### 变量与基本数据类型
