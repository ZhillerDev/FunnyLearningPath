## 第一阶段

### 自动类型转换

多种数据混合运算，系统自动转换为容量大的数据类型后再执行计算

低精度数值赋值给高精度变量，执行自动转换；反过来不行，会报错

`byte、short、char` 之间不会发生相互转换

`boolean` 不参与转换

<br>

### 强转

数据精度从高到低，就需要使用强转

char 类型变量可以保存数字，但是你不能直接把 int 变量赋值给 char 变量

<br>

### String 转换

你可以使用 string 类型的变量转换成任意类型的变量

如下代码

```java
String str = "123";

int num1 = Int.parseInt(str);
float num2 = Float.parseFloat(str);
```

<br>

### 标识符命名规范

包名：所有字母均小写 `com.zhiller.xxx`

类名、接口名：大驼峰 `FoodController`

变量名、方法名：小驼峰 `getName`

常量：全大写，单词之间下划线隔开

<br>

### 原码、反码、补码

二进制最高位是符号位，0 负数，1 正数  
正数的三个码都一样

负数反码：原码符号位不变，其余位取反  
负数补码：反码+1

0 的反码补码均为 0

<br>

### 数组

创建数组

数组初始化器创建数组时，编译器会根据初始化器的元素个数动态计算数组长度，并为数组分配内存空间。  
每个元素的值在编译时就确定了，并且在运行时直接被存储在数组对象中的连续内存位置上。

关键字 new 创建数组时，需要明确指定数组的长度，并在运行时动态分配内存空间。

```java
// 数组初始化器
int[] arr1 = {1,2,3,4,5};

// 关键字new创建数组
int[] arr1 = new int[10];
arr1={1,2,34,5};
```

<br>

## 第二阶段

### 类

可变参数本质上就是一个数组  
可变参数实参可以为 0 个或者任意多个

可变参数可以和普通参数放在一起，但是他必须要在所有参数的最后面（倒数第一个）

一个形参列表仅可存在一个可变参数

```java
public int len(int... nums){
    return nums.length;
}
```

<br>

### 继承

子类继承所有属性和方法；  
非私有属性和方法可以直接在子类访问；  
私有属性必须通过父类公有方法来间接访问；

子类必须调用父类构造器完成初始化

子类默认调用父类无参构造，若父类不含无参构造，则需要借助 super 来指定一个构造函数

`super()`必须放在构造函数第一行

`super()`和 `this()`不可共存

Java 遵循单继承模式，子类只能继承一个父类！

<br>

### Super

super 用于指代父类，如`super.a`就表示调用父类中的公开属性 a

父类中被定义为 final 的属性或方法将无法被重写

对于父类中的私有属性，可以在父类中添加对应的 `getter` 和 `setter` 方法，来让子类间接操纵它

```java
public class SuperDemo {
    public static void main(String[] args) {
        B b = new B(12);
        b.canChange();
        b.cannotChange();
        b.setC(100);
        System.out.println(b.getC());
    }
}

class B extends A {
    public B(int num) {
        super(num);
        System.out.println(super.a);
    }

    @Override
    public void canChange() {
        System.out.println("i changed this method!!!");
    }
}

class A {
    int a, b;

    public int getC() {
        return c;
    }

    public void setC(int c) {
        this.c = c;
    }

    private int c;


    public A() {
        System.out.println("empty a");
    }

    public A(int num) {
        this.a = num;
    }

    public final void cannotChange() {
        System.out.println("this method cannot be changed");
    }

    public void canChange() {
        System.out.println("you can change this method");
    }
}

```

<br>

如果子类中有和父类重名的方法，则调用父类中重名方法时必须使用 super  
若无重名方法，则用 super、this、直接指代都可以！！！

若直接调用方法，会先从当前类开始找，找不到再从父类中找，如果还找不到就一直迭代查询，直到 Object 类为止

若一条继承链上有许多类都出现了同名的方法，则最底层的类使用 super 调用同名方法时，遵循就近原则；  
比如祖父类、父类、子类同时拥有同名方法，则 super 优先安装就近原则调度父类中的同名方法；

<br>

super 与 this 的比较

- this 调用的都是本类中的属性和方法，除非子类没有，才不得不调用父类
- super 直接调用的就是父类属性和方法

<br>

### 重写 Override

重写必背三大规定

1. 子类方法名、参数要和父类完全一致
2. 子类返回值类型必须和父类一样或者为父类返回值类型的子集
3. 子类不可缩小父类访问权限（比如父类 public，子类重写不可以设置为 private）

访问权限大小对比：`public>protected>default>private`

<br>

### 多态

对于方法，可以存在两种多态形式

1. 重载多态：定义同名方法，但参数数量不同，通过传参数量来使用对应的方法
2. 重写多态：B、c 类同时继承 A 类，但俊重写了同名方法 zoo，那么实例化 B、C 类后，调用对应的同名方法就可实现重写多态

<br>

类的多态

对于一个对象，其编译类型和运行类型可以不一致；  
编译类型看等号左边，运行类型看等号右边（如`Animal dog = new Dog()`）；  
编译类型不可变动，但是运行类型可以改变；

```java
public class PolyDemo {
    public static void main(String[] args) {
        Animal dog = getAnimal(new Dog());
        dog.cry();          // dog cry
        dog.walk("tom");    // tom
    }

    private static Animal getAnimal(Animal animal) {
        return animal;
    }
}

class Animal {
    public Animal() {
    }

    public void cry() {
        System.out.println("animal cry");
    }

    public void walk(String name) {
        System.out.println(name);
    }
}

class Dog extends Animal {
    public Dog() {
        super();
    }

    @Override
    public void cry() {
        System.out.println("dog cry");
    }
}
```

<br>

### 多态转型

向上转型：父类引用指向子类对象

`Animal dog = getAnimal(new Dog());`  
此时可以访问父类 Animal 中的所有成员；
若子类还重写了父类中对应方法，那么访问方法时会优先使用子类中重写的方法；  
不能访问在子类 Dog 中新定义的成员！！！（这里不包括子类重写的方法）

<br>

向下转型：子类执行父类的引用

转型后，可以调用子类中的所有方法；且转型内容必须是父类的引用而非父类的对象

```java
Animal animal = new Animal();

Cat cat = (Cat) animal;
```

<br>

如果要检测某个对象是不是每个类的实例，可以借助 instanceOf  
例如：`dog instanceof Animal`

<br>

### 动态绑定

动态绑定的基本原理：

1. 当调用对象方法时，方法会和对象的内存地址与运行类型绑定
2. 当调用对象属性时，无动态绑定，哪里声明就用那个

<br>

分析下方代码：

- 定义父类 BindingA，其中有一个属性值 a=10
- 定义子类 BindingB，重写方法 getNum，而且也同时定义了同名属性 a=20
- 使用向上转型的方法，实例化对象 BindingB
- 此时调用 getNum，因为方法存在动态绑定，故使用子类中重写的方法，返回 a+10
- 由于属性无动态绑定，所以应该使用的是子类中定义的 a=20 而不是父类定义的 a=10，故结果返回 20+10=30

```java
public class DynamicBinding {
    public static void main(String[] args) {
        BindingA b = new BindingB();
        System.out.println(b.getNum());  // 30
    }
}

class BindingA {
    public int a = 10;

    public BindingA() {
    }

    public int getNum() {
        return a;
    }
}

class BindingB extends BindingA {
    public BindingB() {
        super();
    }

    public int a = 20;

    @Override
    public int getNum() {
        return a + 10;
    }
}
```

<br>

### 多态数组

顾名思义，就是在一个数组内体现多态

```java
public class PolyArrDemo {
    public static void main(String[] args) {
        // 定义多态数组
        Fruit[] fruits = new Fruit[3];
        fruits[0] = new Fruit();
        fruits[1] = new Orange();
        fruits[2] = new Pear();

        for (Fruit fruit : fruits) {
            // 根据动态绑定原理，输出不同的值
            fruit.say();
        }
    }
}

class Fruit {
    public void say() {
        System.out.println("this is fruit");
    }
}

class Pear extends Fruit {
    @Override
    public void say() {
        System.out.println("pear");
    }
}

class Orange extends Fruit {
    @Override
    public void say() {
        System.out.println("orange");
    }
}
```

<br>

如果你想要特定的调用每个子类中的新定义的方法

可以先使用 `instanceOf` 判断当前对象是不是子类的一个实例，如果是，再执行调用

所以上文的 for 循环体内可以加个判断，写成下面的样子（我为 Orange 添加了新方法 eatOrange，这里不给出，大家自己实现即可）

```java
for (Fruit fruit : fruits) {
    if (fruit instanceof Orange) ((Orange) fruit).eatOrange();
    fruit.say();
}
```

<br>

### ==运算符

`==`有两种作用

- 进行数值比较，判断两个数是否一致
- 进行地址比较

<br>

下面的赋值方法为引用赋值，故之间地址比较均为 true

```java
A a = new A();
A b = a;
System.out.println(a==b); // true
```

<br>

### hashCode

> hashCode 用于返回一个对象的哈希值，用于提升哈希表效率

两个引用指向同一对象，哈希值必定一致；  
哈希值一致不一定表示引用指向同一对象；

哈希值不完全等于地址值

<br>

### finalize 方法

对象被垃圾回收时，自动调用的方法；  
可以重写该方法，让对象再被释放资源前做一些什么；

采用引用计数法，当 JVM 发现某个对象的引用次数为 0 时，就会执行垃圾回收程序来释放该对象资源

GC 机制由系统决定，当然也可以使用 `System.gc()` 主动触发回收

<br>

## 第三阶段

### 类变量

类变量实际上就是普通变量加上一个 static  
也称为静态变量

该变量会被该类的所有实例所共享；

```java
class A{
    public static int count = 0;
}
```

直接使用 `类名.类变量名` 来执行访问

没有加上 static 的就是所谓的实例变量

类被加载时，类变量就初始化完毕了，就是说你无需实例化对象就可以直接从类调用该类变量

类变量的生命周期是：类初始化开始到其销毁为止

<br>

### 类方法

类方法也就是静态方法

普通方法加上一个 static 即可，具体调用方法和作用可以直接参考类变量

类方法可以通过类名调用，也可以通过对象名调用；  
类方法随类的初始化而加载，结构信息存储于方法区；  
类方法无 this 参数，而普通方法有 this 参数；

<br>

> 静态方法只能访问静态的成员（即静态属性和静态方法）；普通方法则无限制

<br>

### main 方法

由于 main 方法自己就是一个静态方法，故也只能调用同类内的静态成员

对于普通成员，则需要实例化自身再执行调用

```java
package chapter2;

public class MainDemo {
    public static void main(String[] args) {
        // 静态方法可以直接调用
        MainDemo.func1();

        // 非静态方法必须实例化自身才可以调用
        MainDemo mainDemo = new MainDemo();
        mainDemo.func2();
    }
    public static void func1(){
        System.out.println("static function");
    }
    public void func2(){
        System.out.println("normal function");
    }
}
```

<br>

众所周知，main 方法接收一个 args 字符串数组，用于命令行添加可变长参数

所以当我们使用命令行执行 java 程序是，可以传入任意长度的参数：  
`java [类名称] asd asd asd`

<br>

### 代码块

代码块有两种：static 代码块和普通代码块

static 代码块可看做对类的初始化，它随着类的加载而执行，且仅执行一次；  
普通代码块是当每个对象被创建就执行一次；

类被加载的时刻：

1. 创建对象实例
2. 创建子类对象实例，父类会被加载
3. 使用类内静态成员

> 普通代码块只有在对象实例化才会被调用，故我们直接使用类内静态成员而不实例化对象，是不会触发普通代码块的！

<br>

创建一个类时，对应的调用顺序：

1. 静态代码块（如果有多个，则按顺序调用）
2. 普通代码块（如果有多个则按顺序调用）
3. 构造函数

<br>

创建一个子类是，对应的调用顺序

1. 父类静态代码块和静态属性
2. 子类静态代码块和静态属性
3. 父类普通代码块与普通属性初始化
4. 父类构造函数
5. 子类普通代码块与普通属性初始化
6. 子类构造函数

<br>

### 单例模式

#### 饥饿式

```java
class Single1 {
    private Single1() {
    }

    private static final Single1 instance = new Single1();

    public static Single1 getInstance() {
        return instance;
    }
}
```

<br>

#### 懒汉式

```java
class Single2 {
    private Single2() {
    }

    private static Single2 instance;

    public static Single2 getInstance() {
        if (instance == null) {
            instance = new Single2();
        }
        return instance;
    }
}
```

<br>

### final

final 经常被称为终结修饰符，被他修饰后一般具有如下功能

1. 阻止类被继承
2. 阻止父类的方法被覆写
3. 阻止属性被修改
4. 阻止局部变量被修改

<br>

被 final 修饰的属性只能在两个位置初始化：定义时；静态代码块里面；  
不要试图在构造函数里面为 final 变量赋值！！！

你没有必要在为一个 final 类下的方法设置 final 修饰

final 和 static 搭配工作效率更高哦！

<br>

### 抽象类

抽象类必背规则

1. 抽象类不可实例化
2. 抽象类可以没有抽象方法
3. 类内只要存在一个抽象方法，他就必须声明为抽象类
4. abstract 仅能修饰方法和类
5. 抽象类内可以有任何普通类所拥有的成员
6. 一个类继承了抽象类，就必须实现其中所有的抽象方法，除非这个类也是抽象类
7. 抽象方法不能有函数体
8. 抽象方法不可用 private，final，static 等阻止重写的修饰符来修饰

<br>

简易的根据上述知识构筑的抽象类和抽象方法实验代码

```java
package chapter2;

public class AbstractDemo {
    public static void main(String[] args) {
        AbstractEntity entity = new AbstractEntity();
        entity.getName();
        entity.sayHi();
    }
}

abstract class Abstract1 {
    public abstract void getName();

    public void sayHi() {
        System.out.println("hw");
    }
}

class AbstractEntity extends Abstract1{
    @Override
    public void getName() {
        System.out.println("no name");
    }
}
```

<br>

### 接口

接口内的静态方法、默认方法可以自带函数体，其余的函数都不可以有函数体

```java
interface USBInterface {
    public void getType();

    // 默认方法
    default public void defTest(){
        System.out.println("default test");
    }

    // 静态方法
    public static void staticTest() {
        System.out.println("static test");
    }
}
```

<br>

接口使用细节
