### Flow

#### intellij 配置

对于 intellij idea 2002 版本及以上的 IDE，都已捆绑 kotlin 插件，无需我们自主安装

但如果我们想要使用 kotlin flow 数据流操作的语法支持的话，依旧需要下载 `coroutines-core` 依赖

<br>

首先去 maven 仓库下载对应 jar 包：[下载 1.3.2 版本的 coroutines-core](https://mvnrepository.com/artifact/org.jetbrains.kotlinx/kotlinx-coroutines-core/1.3.2)

新建一个项目，项目管理方式 maven 或者 idea 都可以无所谓

依次点击文件->项目结构->模块，选择你要添加依赖的模块  
点击绿色加号，选择第一项，导入我们刚刚下载好的 jar 包，然后勾选即可

![](../imgs/kotlin/flow/kf1.png)

<br>

#### 基础

`flow{}` 创建新的流  
`flowOf()` 根据已有数据创建流

`emit` 为流插入一个元素  
`collect` 对流做出的操作（一般均位于结尾被调用）

```kotlin
fun main() = runBlocking {
    flow {
        emit(1)
        emit(2)
    }.collect {
        println(it)
    }
}
```

<br>

`asFlow` 把已有数据集转换为流  
`filter` 过滤器  
`take` 取出当前链上结果的前 N 个数据

```kotlin
fun main() = runBlocking {
    (1..10).asFlow()        // 将已有数据转换为流
        .map { it*100 }
        .filter { it>500 }
        .take(2)
        .collect { println(it) } // 600 700
}
```

<br>

`onStart` 流开始前执行  
`onCompletion` 流完成后执行

```kotlin
fun main() = runBlocking {
    (1..10).asFlow()
        .onStart { println("我准备好了") }
        .onCompletion { println("我的活干完了") }
        .collect { println(it) }
}
```

<br>

#### flowOn

flowOn() 指定协程上游执行所在池

如下代码可知，上游协程执行 map，被显式规定在了 IO 池中，而下游的 collect 部分则依旧在 MAIN 池中

```kotlin
fun main() = runBlocking {
    (1..2).asFlow()
        .map { println(it) }
        .flowOn(Dispatchers.IO)
        .collect { println("collect") }
}

// 输出结果
// 1
// 2
// collect
// collect
```

<br>

`launchIn` 即针对下游协程需要用到的 Dispatcher

```kotlin
val customDispatcher:ExecutorCoroutineDispatcher = Executors.newSingleThreadExecutor{
    Thread(it,"null").apply { isDaemon=true }
}.asCoroutineDispatcher()

fun main() = runBlocking {
    val scope = CoroutineScope(customDispatcher)
    (1..2).asFlow()
        .map { println(it) }
        .flowOn(Dispatchers.IO)
        .onEach { println("每次执行弹出") }
        .launchIn(scope)
    delay(100)
}
```

<br>
