### Npm 缺点

不知道你有没有发现，每当创建一个新项目时，都必须手动重新安装依赖（哪怕一秒前我们刚刚在另一个项目中安装了同一依赖）

这无意中导致了项目的 node_modules 占用空间极大，且依赖无法复用，频繁下载浪费大量时间

除此之外，npm 还会引入所谓 `幽灵依赖` ，即会静默安装依赖的依赖；  
比如我们本来想装一个依赖，他却同时给你装了依赖的依赖

依赖树问题：
举个栗子，你同时安装依赖 A 和依赖 B，二者均需要同一个附加依赖 C 才可以运行，npm 就会死板的将依赖 C 下载两次，每次都单独指向对应支持的依赖，他不会使用引用的方式让依赖 A 和依赖 B 共用同一个依赖 C  
所以最终我们可能只会使用到一个依赖 C 却安装了 N 个他的副本，你说冤不冤？

<br>

### Pnpm

> 官网：https://pnpm.io/zh/

<br>

#### 优点与包管理形式

pnpm 使用了扁平的包管理形式，采用文件内容寻址（摒弃了速度慢的文件位置寻址）

杜绝“幽灵依赖”现象：
仅我们明确安装的依赖会出现在 node_module 文件夹下，  
而依赖的依赖以 `<package-name>@<version>` 的方式平铺在 `.pnpm` 目录下

pnpm 的依赖管理手段：

1. install 新依赖时，pnpm 会将其安装到一个总文件夹内，该文件夹所有依赖都仅存在一份，不会重复
2. 项目安装依赖时会通过硬链接连接到总文件夹对应的依赖，如果总文件夹没有，才会下载
3. 项目中的依赖以及依赖的依赖之间通过软连接联系

<br>

#### 安装与使用

卸磨杀驴，直接使用 npm 全局安装 pnpm：`npm install -g pnpm`

或者使用官网推荐的，powershell 安装：`iwr https://get.pnpm.io/install.ps1 -useb | iex`

<br>

其余的主要功能和 npm 完全一致  
初始化 package.json：`pnpm init`  
安装依赖：`pnpm install xxx`  
卸载依赖：`pnpm uninstall xxx`  
跑代码：`pnpm run xxx`

<br>

#### monorepo

pnpm 支持 `monorepo` ，其余的包管理工具一般都是 `multirepo`

monorepo：把 多个项目模块 放在 一个主干仓库之中管理  
multirepo：一个项目仅可对于一个仓库

<br>

monorepo 优势点

1. `工作流一致性` 所有项目位于一个仓库，统一管理十分方便，依赖变动会迅速被感知并更新到最新的代码，无需关注版本变动带来的问题
2. `项目基建成本降低` 因位于同一仓库，故所有下属项目均使用一套开发流程与环境，新加项目时可以迅速使用当前环境
3. `团队协作高效` 同一仓库当然可以方便所有开发者快速维护

<br>
